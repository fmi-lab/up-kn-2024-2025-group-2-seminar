# Седмица 12 - Структури

## Структури в C++
Структурите в C++ са съставен тип данни, който представлява съвкупност от елементи от произволен тип, обединени в един общ обект. Елементите в структурите се наричат полета или член-данни и по подразбиране имаме свободен достъп до тях. Няма ограничение в броя на полетата в структурата. Дефиницията на структура създава потребителски тип, с който може да оперираме по същия начин, както и с останалите типове в езика. Пример за дефиниция на структура:
```c++
struct Person {
  char name[30];
  int age;
  double weight;
};
```

## Работа със структури
След като дефинираме структура, трябва да можем да създаваме нейни инстанции - това са обектите, които са от типа, зададен от структурата. Както стана дума, с тях се оперира по същия начин както и с останалите типове - следователно можем да създаваме инстанции статични и динамично. Да разгледаме различните начини за създаване на инстанции на структурата от горния пример:
```c++
Person p1;
Person p2{"Ivan", 20, 74.5};
Person p3 = {"Ivan", 20, 74.5};
Person* p4 = new Person;
Person* p5 = new Person{"Ivan", 20, 74.5};
```

- `p1` създава обекта със стойности по подразбиране на полетата;
- `p2` създава обекта със стойности на полетата равни на тези в къдравите скоби. Стойностите в къдравите скоби се присвояват на полетата в реда, в който са дефинирани полетата в структурата. Това е познатият ни от преди `list initialization`;
- `p3` води до същия резултат като `p2`, с разликата, че това е стандартния начин за присвояване на стойност на променлива, който сме свикнали да ползваме при работата с прости типове. На практика обектът се създава от дясната страна на `=` и само се присвоява на променливата отляво - т.е. `p3` копира стойностите на полетата в обекта от дясно на `=`;
- `p4` създава динамично обект със стойности по подразбиране;
- `p5` създава динамично обект по същия начин както `p2`. Ако се опитаме да сложим `=` като в `p3` ще получим грешка, понеже при динамично инициализиране на обекти трябва да укажем какви да са стойностите на техните полета и не можем да копираме други структури в тях.

След като видяхме как се инициализират обекти нека видим как да достъпваме техните полета:
```c++
std::cout << p2.name << ' ' << p2.age << ' ' << p2.weight << '\n'; // -> Ivan 20 74.5
std::cout << p5->name << ' ' << p5->age << ' ' << p5->weight << '\n'; // -> Ivan 20 74.5
```

- първият ред е пример за достъпване на полетата от обект - това става с оператора `"."`. Освен, че може да ги достъпваме, може и да променяме стойностите на полетата:
```c++
p2.age = 21;
```
- вторият ред е пример за достъпване на полетата от указател към обект. На практика операторът `"->"` е просто синтактична захар за дереференциране на обекта и използването на `"."`:
```c++
(*p5).name <=> p5->name
```

## Представяне на структурите в паметта
Както стана ясно, структурите просто обединяват няколко променливи в общ обект. Това ни навява на мисълта, че най-вероятно структурите се представят в паметта, като просто полетата се разположат последователно в нея. Можем да използваме оператора `sizeof`, за да видим колко точно байта заема подадения обект в паметта. Нека го използваме за нашата структура `Person`:
```c++
std::cout << sizeof(Person) << '\n';
```

Очакваме резултата от горния ред да бъде сумата от размерите на полетата в структурата - 30 + 4 + 8 = 42. В действително резултата е 48. Това е така, защото полетата се подравняват - адресът, от който започват полетата, трябва да се дели на техния размер. Допълнително, общият размер на структурата трябва да се дели на машинната дума - в случая 8 байта. Да разгледаме следните 2 примера:
```c++
struct Person1 {
  char blood_type;
  double weight;
  char name[30];
};

struct Person2 {
  double weight;
  char name[30];
  char blood_type;
};

int main() {
  std::cout << sizeof(Person1) << ' ' << sizeof(Person2) << '\n';
  return 0;
}
```

Резултата от горния пример е, че `Person1` заема 48 байта, а `Person2` - 40 байта. Разликата идва от позицията на `blood_type` - в първия случай, `weight` трябва да започва от адрес, който се дели на 8 и понеже `blood_type` заема само 1 байт, трябва да се допълнят още 7 байта и накрая имаме общо 46 байта, но трябва общият размер да се дели на 8, следователно получаваме общо 48 байта. В другия случай не се налага да се добавят никакви байтове между отделните полета, следователно накрая имаме общо 39 байта и отново трябва да се подравни самата структура и получаваме общо 40 байта. Това показва, че на практика има значение в какъв ред ще слагаме полетата в структурите.

## Рекурсивни структури
Сега като знаем как се разполагат структурите в паметта, можем да си зададем въпроса какво се случва в следния пример:
```c++
struct Person {
  char name[30];
  Person mother; 
};
```

За да се разположи в паметта, първо трябва да се сметне размера на отделните полета на структурата. Но когато трябва да се изчисли размера на `mother` трябва да се изчисли рекурсивно размерът на `Person`. Така получаваме безкрайна рекурсия за смятане на размера на `Person` и затова ще получим компилационна грешка. Начинът, по който можем да разрешим проблема, е като променим типа на `mother` да е `Person*` - указателите винаги имат фиксиран размер - размерът на машинната дума. Така вече можем да сметнем размера на `Person` (който е?) и до голяма степен да запазим поведението, което сме очаквали първоначално за тази структура.

## Структури и функции
Структурите се предават по стойност на функциите, подобно на простите типове данни. Следователно всички промени, направени по структурите във функциите, няма да се отразят извън тях. Ако обаче искаме да се отразят, отново можем просто да подаваме структурите като указатели или референции. Когато обаче подаваме структурите по стойност, това което се случва е, че се създава копие на подадения обект и във функцията работим с това копие. За да се направи това копие, трябва да се копират всички полета на обекта в нов обект, което може да бъде много тежка операция в зависимост от това колко е голям размера на обекта. Затова ще предпочитаме да подаваме обектите като референции и ако не искаме те да се променят в тялото на функцията, ще добавяме ключовата дума `const` в дефиницията на параметъра. Така ще избегнем това копиране и ще работи директно с подадения обект. Копиране има и при връщането на обект като резултат на функция, но тук трябва да внимаваме кога ще изберем да върнем референция, за да не върнем референция към обект, чиято област на действие ще изчезне след приключване на функцията. Отново, ако не искаме резултата от функцията да се променя, можем да сложим `const` при типа на връщане. Пример:

```c++
// Правилно:
void print(const Person& person) {
  std::cout << person.name << ' ' << person.age << ' ' << person.weight << '\n';
}

Person& grow(Person& person) {
  ++person.age;
  return person;
}

// Грешно:
const Person& grow(const Person& person) {
  Person new_person = person;
  new_person.age = person.age + 1;
  return new_person;
}
```

## Задача 01 - Масив
Напишете структура, която представлява динамичен масив от цели числа. Помислете какви полета трябва да има тази структура, за да може цялата информация за масива да се съдържа в нея. Като използвате тази структура, напишете следните функции:
- `push_back` - добавя нов елемент на края на масива;
- `insert` - добавя елемент на конкретна позиция в масива. Ако няма толкова елементи, колкото е позицията, да се добави на края на масива;
- `append` - по подадени 2 масива, връща нов, който съдържа елементите на първия и втория масив, залепени едни след други;
- `remove` - по подаден елемент премахва първото срещане на елемента от масива. Ако няма такъв елемент да не прави нищо;
- `slice` - по подаден масив, начален индекс и размер, връща нов масив с начало началния индекс и размер равен на подадения размер. Ако размерът е прекалено голям да се вземат всички елементи до края на масива. Ако индекса е невалиден да се върне копие на подадения масив.

## Задача 02 - Студенти
Да се напише структура, която представлява студент в университет, съдържаща име, курс и спсисък от оценки. Оценките представляват структура от името на предмет и оценката към него. Да се напише структура университет, представляваща списък от студенти. Като използвате тези структури напишете следните функции:
- `add_student` - приема университет и студент и добавя студента към университета;
- `add_mark` - приема университет, име на студент и оценка. Добавя оценката към списъка с оценки на студента от университета. Ако такъв студент не съществува да не прави нищо;
- `get_by_year` - приема университет и курс и връща списък от студентите в подадения курс;
- `get_by_subject` - приема университет и име на предмет и връща списък от студентите, имаще оценка по подадения предмет;
- `get_results_for_subject` - приема университет, име на предмет и интервал. Връща списък от студентите в университета, които имат оценка по подадения предмет в подадения интервал;
- `graduate_year` - приема университет и спсисък от имена на студенти. За всеки студент от университета, чието име е в списъка, да се увеличи курсът му с 1. Ако курсът стане повече от 4, студентът да се премахне от университета.

## Задача 03 - Работници
Да се напише структура, която представлява работник във фирма, съдържаща име, позиция и директен шеф на работника, който също да е работник. Ако работникът няма директен шеф (т.е. е директор на фирмата), полето за шеф трябва да има подходяща стойност. Да се напише функция, която приема двама работника и намира първият общ шеф и на двамата (т.е. общият им шеф с най-малка позиция). Приемаме, че директорът на фирмата е общ шеф на всички (т.е. всеки двама работници имат шеф).

### Пример:
```c++
Иван                ->  Георги                ->  Петър               ->  Тодор
Обикновен работник  ->  Технически наставник  ->  Мениджър на проекта ->  Директор на фирмата

Александър  ->  Таня                      ->  Петър               ->  Тодор
Санитар     ->  Отговорник трудова база   ->  Мениджър на проекта ->  Директор на фирмата

Вход:           Изход:
Иван            Петър
Александър
```