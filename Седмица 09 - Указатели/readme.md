# Седмица 09 - Указатели

## Какво са указателите?
Указател (pointer) е променлива, която има като стойност адреса на някакъв обект в паметта. Тези обекти може да са други променливи, масиви, инстанции на класове, функции и др. Указателите са параметризиран тип, т.е. за неговото дефиниране, трябва да знаем типа на обекта, към който ще сочи. Можем да достъпим данните, към които сочи указателят, като го дереферинцираме. Да разгледаме следните примери за дефиниране и ползване на указатели:
```c++
int a = 5;

int* n;
int* p = nullptr;
int* q = &a;
int** r = &q;

std::cout<<*q;
```
- указателят `n` няма инициализация и не можем да сме сигурни какво сочи, съответно неговото дереференциране би довело до недефинирано поведение;
- указателят `p` е инициализиран с `nullptr` - това e запазената дума за нулев указател, т.е указател "без стойност". `nullptr` се оценява до 0, но не може да се дереференцира, понеже това би означавало да се вземе стойността на адрес 0, което е забранено;
- указателят `q` е инициализиран с адреса на променливата `a` и неговото дереферинциране води до резултат `5`. От този пример се вижда, че когато използваме операторът `&` пред променлива, получаваме адреса на тази променлива;
- указателят `r` е инициализиран с адреса на указателя `q`. Указателите, подобно на обикновените променливи също имат адрес в паметта, който може да се достъпва по същия начин. Дереференцирането на `r` дава адреса на `q`, а не стойността сочена от q.
- на последния ред извеждаме дереференцираната стойност на `q`. Използването на операторът `*` преди указател дереференцира указателя, а използването му след тип обявява, че променливата е указател, правете разликата!

## Константни указатели и указатели към константа
Ключовата дума `const` указва, че обекта, към който се отнася, не може да бъде променян. При указателите се появява объркването към кое точно сочи `const` - към самия указател или към типа на обекта, сочен от указателя. Да разгледаме следните примери:
```c++
int a = 5;

const int *p = &a;
int const *q = &a;
int *const r = &a;
const int* const s = &a;

// Кои от следните редове дават компилационна грешка?
p = q;
*p = 7;
r = q;
*r = 9;
s = q;
*s = 1;
```
- указателите `p` и `q` са указатели към константа - не можем да променяме стойността, сочена от тях, но можем да променяме какво сочат;
- указателят `r` е константен указател - не можем да променяме към какво сочи, но можем да променим сочената от него стойност;
- указателят `s` е константен указател към константа - не можем да променяме нито стойността, сочена от него, нито обекта, към който сочи.

Лесно правило, по което можем да ги помним е, че ако `const` стои преди `*` значи е указател към константа, а иначе - константен указател.

## Указатели, масиви и символни низове
Както видяхме на предни упражнения, при опит за извеждане на масив, всъщност получавахме шестнайсетично число. Това шестнайсетично число всъщност е адресът на първия елемент от масива. Това е така, защото на практика името на масива е константен указател към първия му елемент. Същото е вярно и за символните низове, все пак те също са масиви. При символните константи обаче има разлика - те са указатели към константа. Тогава в следния пример първият ред е верен, а вторият води до насилствено преобразуване на типове, което в повечето компилатори не е позволено:
```c++
const char* str1 = "Hello world";
char* str2 = "Hello world";
```

## Указателна аритметика
Указателната аритметика е способ, който ни позволява да преместваме указател напред или назад в паметта. Понеже указателите на практика са просто шестнайсетични числа, то можем да добавяме или изваждаме от тях други числа. Например:
```c++
int* p;
std::cout << p << " " << p + 2 << '\n';
```
Ако изпълним този пример ще видим, че адресът е нараснал не с 2, а с 8. Това е така, защото този запис означава: "премести указателя 2 клетки напред в паметта". Но какъв е размерът на клетките? Отговорът на този въпрос е: зависи от типа на елементите в тези клетки. В случая клетката има размер 4 байта, понеже типът `int` заема 4 байта в паметта, ако беше `char` щеше да е 1, `double` - 8 и т.н. Това всъщност ни улеснява, понеже не се налага да смятаме колко точно байта да се отместим (особено, когато размерът на типовете е променлив спрямо платформата). Въпреки, обаче, че можем свободно да се предвижваме в паметта, можем да дерефернцираме само тези клетки, до които има достъп нашата програма. В горния пример, ако се опитаме да дереференцираме указателя след отместването, в най-добрия случай ще имаме недефинирано поведение, ако сме още в рамките на паметта, заделена за програмата, а в най-лошия - `Segmentation fault`, ако излезем извън нея. Но тогава с какво ни помага указателната аритметика? Ами всъщност чрез нея можем да индексираме масивите. Щом като имаме указател към първия елемент на масива, то чрез неговото изместване можем да достъпим и останалите елементи. Всъщност се оказва, че следните 2 реда са еквивалентни и първият е синтактична захар за втория:
```c++
std::cout << arr[i] << '\n';
std::cout << *(arr + i) << '\n';
```
Но понеже събирането е комутативна операция, можем да напишем и следното извращение (което силно не препоръчвам):
```c++
arr[i] <=> *(arr + i) <=> *(i + arr) <=> i[arr]
```

## Референции
Референциите (препратки, псевдоними, references) е променлива, която представлява копие на друг обект, който не може да се различи от оригинала - промените направени по оригинала се отразяват и в копието и обратно. Можем да си мислим, че референциите са нещо като "преки пътища" на обекти. Дефинират се по следния начин:
```c++
int a = 5;
int& b = a;
a += 5;
std::cout << a << " " << b << '\n'; // 10 10
```
Както се вижда от примера, за да оказжем, че една променлива е референция, трябва да сложим `&` след типа. На практика референцията е синтактична захар за дереференциран константен указател. Това означава, че дефиницията задължително трябва да е съпроводена с инициализация, понеже веднъж създадена, референцията не може да смени това, което реферира.

## Указатели, препратки и функции
Когато подаваме указатели като параметри на функции те се държат като нормални променливи - всички промени направени по тях във функцията не се отразяват извън нея. Но промените, направени по стойностите, сочени от тях, ще се отразят, понеже тези промени са директно в паметта. Това всъщност ни дава обяснение, защо промените, направени по елементите на масив се отразяват извън функциите, за разлика от простите типове данни. Аналогично, ако подаваме променливи по референция на функции, промените, направени по тях, ще се отразят извън функцията. Това ни дава повече гъвкавост при работата ни с функциите - ако искаме например да върнем повече от един резултат, можем да подадем променлива по референция и в нея да запишем допълнителния резултат. Да разгледаме следния пример:
```c++
void swap(int& lhs, int& rhs) {
  int temp = lhs;
  lhs = rhs;
  rhs = temp;
}
```
Тази функция разменя стойностите на 2 цели числа, като запазва промените извън самата функция. Това не можехме да направим до сега, защото не знаехме как да "върнем" двете нови стойности на числата.

### Инструкции за задачите
В следващите задачи, под това да подаваме масив на функция, ще разбираме да подаваме указател към първия му елемент и указател след последния му елемент.

## Задача 00 - Принтиране
```c++
void print(const int* begin, const int* end);
```
Напишете функция, която принтира масив.

## Задача 01 - Upper Bound
```c++
const int* upper_bound(const int* begin, const int* end, int element);
```
Напишете функция, която по подаден сортиран масив и число, връща указател към първия елемент от масива, който е по-голям от подаденото число. Ако такъв елемент не съществува, функцията да връща `nullptr`.

### Пример:
```c++
const int arr[]{0, 1, 2, 5, 7};
const int *element = upper_bound(std::cbegin(arr), std::cend(arr), 4);
const int *not_found = upper_bound(std::cbegin(arr), std::cbegin(arr) + 2, 4);

print(element, std::cend(arr)); // -> 5 7
if(!not_found) {
  std::cout << "Not Found\n"; // -> Not Found
}
```

## Задача 02 - Еднакви масиви
```c++
bool equal(const int* first_begin, const int* first_end, const int* second_begin, const int* second_end);
```
Напишете функция, която проверява дали елементите на два масиви съвпадат.

### Пример:
```c++
const int arr[]{1, 2, 1, 3};
const int arr2[]{1, 2};

std::cout << std::boolalpha << equal(std::cbegin(arr), std::cbegin(arr) + 2, std::cbegin(arr2), std::cend(arr2)) << '\n'; // -> true
std::cout << std::boolalpha << equal(std::cbegin(arr), std::cend(arr), std::cbegin(arr2), std::cend(arr2)) << '\n'; // -> false
```

## Задача 03 - Замяна
```c++
void replace(int* begin, int* end, int old_value, int new_value);
```
Напишете функция, която заменя всички срещания на елемент в масив с подадена нова стойност.

### Пример:
```c++
int arr[]{0, 9, 2, 9, 3, 9};
replace(std::begin(arr), std::end(arr), 9, 1);
print(std::cbegin(arr), std::cend(arr)); // -> 0 1 2 1 3 1
```

## Задача 04 - Завъртане
```c++
void rotate(int* begin, int* mid, int* end);
```
Напишете функция, която по подаден масив и указател `mid` към елемент в него, разменя елементите в интервала [mid, end) с тези в интервала [begin, mid).

### Пример:
```c++
int arr[]{0, 1, 2, 3, 4};
rotate(std::begin(arr), std::begin(arr) + 2, std::end(arr));
print(std::cbegin(arr), std::cend(arr)); // -> 2 3 4 0 1
```

## Задача 05 - Търсене
```c++
const int* search(const int* first_begin, const int* first_end, const int* second_begin, const int* second_end);
```
Напишете функция, която по подадени 2 масива, връща указател към първия елемент в първия масив, от който започва да се среща втория. Ако няма такъв елемент, да се върне `nullptr`.

### Пример:
```c++
const int arr[]{0, 1, 2, 1, 2};
const int seq[]{1, 2};
const int* begin = search(std::cbegin(arr), std::cend(arr), std::cbegin(seq), std::cend(seq));
print(begin, std::cend(arr)); // -> 1 2 1 2
```

## Задача 06 - Постфикс
```c++
bool ends_with(const int* first_begin, const int* first_end, const int* second_begin, const int* second_end);
```
Напишете функция, която по подадени 2 масива, проверява дали последните елементи на първия съвпадат с тези на втория.

### Пример:
```c++
const int arr[]{2, 4, 5, 3, 7, 6};
const int arr2[]{7, 6};

std::cout << std::boolalpha << ends_with(std::cbegin(arr), std::cend(arr), std::cbegin(arr2), std::cend(arr2)) << '\n'; // -> true
std::cout << std::boolalpha << ends_with(std::cbegin(arr), std::cbegin(arr) + 5, std::cbegin(arr2), std::cend(arr2)) << '\n'; // -> false
```

## Задача 07 - Последно срещане
```c++
const int* find_end(const int* first_begin, const int* first_end, const int* second_begin, const int* second_end);
```
Напишете функция, която по подадени 2 масива, връща указател към последния елемент в първия, от който започва да се среща втория. Ако няма такъв елемент, да се върне `nullptr`.

### Пример:
```c++
const int arr[]{0, 1, 2, 1, 2, 5};
const int seq[]{1, 2};
const int* begin = find_end(std::cbegin(arr), std::cend(arr), std::cbegin(seq), std::cend(seq));
print(begin, std::cend(arr)); // -> 1 2 5
```

## Задача 08 - Уникалност
```c++
int* unique(int* begin, int* end);
```
Напишете функция, която заменя всяка поредица от повтарящи се елементи в масив само с един от този елемент. Функцията да връща новия логически край на масива.

### Пример:
```c++
int arr[]{1, 2, 1, 1, 3, 3, 3, 4, 4, 5, 4};
int* end = unique(std::begin(arr), std::end(arr));
print(std::cbegin(arr), end); // -> 1 2 1 3 4 5 4
```

## Задача 09 - Разделяне
```c++
const int* partition(int* begin, int* end, int element);
```
Напишете функция, която по подаден масив и естествено число пренарежда масива, така че в началото му да са всички елементи, по-малки от подаденото число, а в края - всички по-големи или равни. Функцията да връща указател към началото на втората група. Редът на елементите в двете групи няма значение.

### Пример:
```c++
int arr[]{4, 7, 1, 3, 2, 6, 5, 9, 0};
const int *mid = partition(std::begin(arr), std::end(arr), 5);

print(std::begin(arr), mid); // -> 4 0 1 3 2
print(mid, std::cend(arr)); // -> 5 9 6 7
```

## Задача 10* - Следваща пермутация
```c++
bool next_permutation(int* begin, int* end);
```
Напишете функция, която нарежда елементите в масив в тяхната следваща пермутация (спрямо лексикалната им наредба). Ако е достигната последната пермутация (т.е. масивът е сортиран в низходящ ред), то той да се пренареди до първата му пермутация (т.е. да е сортиран във възходящ ред) и функцията да върне `false`. Иначе функцията трябва да връща `true`.

### Пример:
```c++
int arr[]{1, 2, 3};

do
{
    print(std::cbegin(arr), std::cend(arr));
    std::cout << std::endl;
} while(next_permutation(std::begin(arr), std::end(arr)));

/*
    1 2 3
    1 3 2
    2 1 3
    2 3 1
    3 1 2
    3 2 1
*/
```