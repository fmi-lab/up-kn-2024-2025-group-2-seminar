# Седмица 11 - Динамична памет

## Стекова памет (Stack)
Всеки път, когато създаваме променлива, ние всъщност казваме на компилатора, че нашата програма се нуждае от определен брой байтове, в които да пази някаква информация. При компилация, общият брой необходими байтове се пресмята и на програмата се предоставя точно толкова памет, колкото си е "поискала". Тази памет се заделя в специална област от паметта на машината наречена стекова памет или просто стек. Това е структура работеща на принципа "първият влязал, последният излязал". На практика, в програмите, които писахме до сега, сме използвали само стековата памет. Нейните бонуси са, че заделянето и достъпването на клетки в нея са бързи операции. Но това, че паметта се заделя веднъж, по време на компилация, е ограничаващо в голяма част от случаите - например няма как да си създадем масив с конкретна дължина, която да се въвежда от стандартния вход.

## Област за динамична памет (Heap)
Областта за динамична памет (още позната като Heap) ни дава решение на горния проблем. Това е участък от RAM паметта, в който можем да заделяме определено количество байтове по време на изпълнение на програмата (от там и името). За разлика от стека обаче, областта за динамична памет не налага строга организация на начина, по който се заделя памет в нея - ако заделим 5 байта и след тях още 10, не е сигурно дали тези 10 нови байта ще се заделят до първите 5 или ще има някакво място между тях. Това прави достъпа до клетките доста по-бавно в сравнение със стека. Заделянето също е по-бавно, защото трябва първо да се намери достатъчно голям свободен участък. Въпреки тези недостатъци, динамичната памет се ползва постоянно, защото в реалния софтуер няма как да предвидим точния брой байтове, които ще са необходими за правилната му работа, преди неговото изпълнение.

## Как се заделя динамична памет?
В C++, за разлика от голяма част от по-модерните програмни езици, трябва ръчно да се грижим за динамичната памет. Това включва и нейното заделяне. Тук на помощ ни идват операторите `new` и `new[]`. Първият заделя само 1 клетка в динамичната памет, докато другият заделя поредица от клетки. Да разгледаме следния пример:
```c++
int* a = new int(5);

int n;
std::cin >> n;

int* arr = new int[n];

for (std::size_t i = 0; i < n; ++i) {
  std::cin >> arr[i];
}
```
На първият ред сме заделили динамично място за едно цяло число и дори сме го инициализирали с 5. Обърнете внимание, че типът на променливата е указател към `int`. Операторът `new` заделя памет в областта за динамична памет и трябва някак си да ни даде достъп до нея - това става като ни върне адреса към мястото, където е заделена тази памет. След това в примера въвеждаме едно число от стандартния вход и заделяме в динамичната памет място за масив от тип `int` с размер, равен на въведеното число, и след това въвеждаме елементите на масива. Обърнете внимание, че отново резултата от оператора `new` е указател, но този път в квадратни скоби сме указали броя на клетките от тип `int`, който искаме да заделим.

## Освобождаване на динамична памет
В горния пример има един проблем - имаме така нареченото изтичане на памет (`memory leak`). Какво означава това? Както стана дума по-рано, трябва да се грижим ръчно за динамичната памет - това включва нейното заделяне, но и освобождаване. Когато блок от кода, в който сме заделили динамично памет, приключи своето изпълнение, тази динамично заделена памет не се освобождава автоматично и тя продължава да изглежда, че се ползва, което не позволява на други програми да я ползват за себе си. Така всъщност ние "пълним" RAM паметта и в някакъв момент ще изглежда, че няма достатъчно място в нея, въпреки че има много клетки, които не се ползват. Това създава много проблеми - от недостатъчно място за други програми до невъзможност на операционната система да продължи нормално работата си. Затова трябва много да внимаваме, когато заделяме динамична памет, да я освобождаваме, когато спрем да я ползваме. Това става с операторите `delete` и `delete[]`. Първият освобождава единична клетка, която сме заделили с `new`, а вторият освобождава цяла поредица от клетки, които сме заделили с `new[]`. За да бъде коректен примерът от по-горе трябва да добавим следните 2 реда в края му:
```c++
delete a;
delete[] arr;
```
Няколко важни неща, за които трябва да внимаваме:
- `delete` работи само с указатели, които сочат данни в областта за динамична памет. Не можем да освобождаваме статично заделена памет;
- памет заделена с `new` се освобождава само с `delete`, както и памет заделена с `new[]` се освобождава само с `delete[]`. В противен случай пак ще имаме изтичане на памет, както и други проблеми;
- трябва да внимаваме да не "изгубим" указателите към динамично заделена памет. Ако презапишем стойността на указател към динамична памет, преди да запазим старата стойност някъде, ние повече няма как да достъпим стария адрес и съответно няма как да освободим паметта на този адрес - следователно имаме изтичане на памет.

## Задача 01 - Сливане
```c++
int* merge(const int* first_begin, const int* first_end, const int* second_begin, const int* second_end);
```
Напишете функция, която по подадени 2 сортирани масива, връща адреса към нов масив, който съдържа сортирани елементите от двата масива. Демонстрирайте коректната работа на функцията в примерна програма. 

### Пример:
```c++
int arr1[] = {1, 4, 6};
int arr2[] = {2, 3, 5, 7};

int* merged = merge(std::begin(arr1), std::end(arr1), std::begin(arr2), std::end(arr2));
print(merged, 7); // -> 1 2 3 4 5 6 7

delete[] merged;
```

## Задача 02 - Филтриране
```c++
char* filter(char* str);
```
Напишете функция, която приема символен низ, и връща нов низ, който е същият като подадения, но с премахнати от него интервали. Размерът на върнатия низ да е точно толкова, колкото символа има в него.

### Пример:
```c++
char str[] = "I am a beginner programmer";
char *result = filter(str);

std::cout << result << '\n'; // -> Iamabeginnerprogrammer

delete[] result;
```

## Задача 03 - Бомби
```c++
int* detonate(int* arr, std::size_t n, int bomb, std::size_t magnitude);
```
Напишете функция, която приема масив и 2 числa, които ще наричаме "бомба" и "магнитуд". Функцията трябва да върне нов масив, след като детонира всички бомби в масива - бомбите се детонират отляво надясно като при детонация всяка бомба премахва от масива себе си и набор от числа отляво и отдясно на себе си равен на магнитута. Демонстрирайте коректността на функцията в примерна програма.

### Пример:
```
Вход:                           Изход:
13                              4 6 0
4 7 1 3 2 3 6 1 8 3 4 5 0
3 2
```

## Задача 04 - Произведение по колони
```c++
int** add_products(int** matrix, std::size_t rows, std::size_t columns);
```
Напишете функция, която приема матрица, и връща нова матрица, която е същата като първата, като е добавен един нов ред, съдържащ произведенията на елементите по колони в оригиналната матрица. Да се напише примерна програма, която очаква от стандартния вход две числа и заделя динамично матрица с размерности равни на тези числа. След това прилага функцията над нея и изкарва на стандартния изход новата матрица.

### Example:
```
Вход:              Изход:
3 4                1 2 3 4
1 2 3 4            5 6 7 8
5 6 7 8            4 3 2 1
4 3 2 1            20 36 42 32
```

## Задача 05 - Свиване на матрица
```c++
int** shrink(int** matrix, std::size_t rows, std::size_t columns);
```
Напишете функция, която приема матрица, и замества с 0 всяко число в нея, в чийто двоичен запис има нечетен брой единици. След това функцията да премахва всички редове и колони от матрицата, които са съставени само от 0 и да връща променената матрица. Да се напише примерна програма, която очаква от стандартния вход две числа и заделя динамично матрица с размерности равни на тези числа. След това прилага функцията над нея и изкарва на стандартния изход новата матрица.

### Example:
```
Input:              Output:
5 5                 3 5 0 
3 2 5 11 4          6 9 15
4 7 8 13 2          0 6 17
6 1 9 14 15
2 4 8 16 0
2 7 6 19 17
```

## Задача 06* - Merge Sort
```c++
void merge_sort(int* begin, int* end);
```
Напишете функция, която сортира масив с алгоритъма за сортиране чрез сливане (merge sort).

### Пример:
```c++
int arr[] = {4, 6, 1, 3, 7, 2};

merge_sort(std::begin(arr), std::end(arr));

print(std::begin(arr), std::end(arr)); // -> 1 2 3 4 6 7
```