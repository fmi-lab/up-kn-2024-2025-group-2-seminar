# Седмица 05 - Масиви

## Какво е масив?

Масив е последователност от елементи, която се представя в паметта като последователни клетки, всяка от които заема толкова място, колкото е размерът на елемента на конкретната позиция в масива. Поради това, че в паметта, масивът се представя като линейна структура, всеки от елементите му може да бъде достъпен по номера му в последователността - казваме, че елементите могат да бъдат индексирани. Важно е да се отбележи, че в C++ първият индекс не е 1, а е 0.

## Дефиниране на масив

В С++, масивите се дефинират по следния начин:

```c++
int arr[5]{1, 2, 3, 4, 5};
```

Да разгледаме отделните части на този запис:

- Дефиницията започва с типа на елементите в масива - в случая това е `int`. В масив може да има елементи само от един тип;
- След това пишем името на масива и след него в квадратни скоби записваме размера на масива. **ВАЖНО: размерът на масива е константен и се задава по време на компилация, т.е. веднъж зададен, той не може да се промени и освен това размерът трябва да е известен преди да се изпълни програмата;**
- Дефиницията може да приключи до тук, но в случая тя е последвана от списък от елементи - това означава, че искаме да запълним масива с някакви първоначални стойности. Те се записват в къдрави скоби, разделени със запетая. Този начин на инициализиране се нарича `uniform initialization`. Ако броят на елементите в списъка е по-малък от броя на елементите в масива, то тогава останалите елементи ще бъдат инициализирани със стойността по подразбиране на техния тип - в случая на `int`, това е 0. Между списъка и размера на масива може да стои знака `=` - резултатът тогава ще бъде същия, но тогава ще има едно допълнително копиране на елемените в списъка (защо, ще разберем в курса по ООП);
- Ако използваме `uniform initialization`, можем да изпуснем размера на масива - тогава той ще се създаде с размерност, равна на броя на елементите в инициализиращия списък;
- Ако при дефиниция на масив не укажем инициализиращ списък, то тогава масивът ще е запълнен с произволни елементи. Достъпът до такива елементи може да доведе до недефинирано поведение на нашата програма.

## Индексиране на масив

Както стана въпрос по-горе, масивите могат да се индексират като започнем от 0. Да разгледаме следния пример:

```c++
int arr[5] = {1, 2, 3, 4, 5};

for (std::size_t i = 0; i < 5; i++)
{
  std::cout<<arr[i]<<' ';
}
```

Този фрагмент от програма извежда всеки от елементите на масива, разделени с интервал. Както се вижда, достъпът до елементите на масива се осъществява като след името на масива в квадратни скоби се сложи индекса на елемента, който искаме да достъпим. Ако се опитаме да достъпим елемент с индекс по-малък от 0 или по-голям или равен на 5 ще получим `Segmentation fault`: това е грешка, която ни казва, че сме се опитали да достъпим част от паметта, до която нямаме достъп. По принцип програмите резервират част от паметта, до която имат достъп, а останалата част от паметта се предпазва от ядрото на операционната система с цел да се предотвратят хакерски атаки и манипулации на паметта.

## Масиви и функции

Да разгледаме следния пример:

```c++
void print(int arr[], std::size_t n) {
  for (std::size_t i = 0; i < n; i++)
  {
    std::cout<<arr[i]<<' ';   
  }
  std::cout<<'\n';
}
```

Тази функция приема масив и число и извежда всичките му елементи, разделени с интервал. Обърнете внимание как се подава масивът - по подобен начин на дефиницията, но в случая в квадратните скоби не е написан размерът. По принцип може да се сложи и размер, но на практика той няма никакво значение - C++ по никакъв начин не ни предпазва от това да подаваме масиви с различен размер или да достъпим елементи извън размера. По-скоро изричното задаване на размера би ни объркало и дало измамно чувство на сигурност, затова ще гледаме да го избягваме. Освен това обърнете внимание, че нямаме никаква информация за броя на елементите в масива. Затова е нужно да се подава още един параметър - този брой. Без него няма да знаем до къде можем да индексираме масива. Сега да видим още един пример:

```c++
void change_first_element(int arr[], int element) {
  arr[0] = element;
}

int main() {
  int arr[5] = {1, 2, 3, 4, 5};

  change_first_element(arr, 6);
  print(arr, 5);

  return 0;
}
```

Резултата от изпълнението на тази програма ще бъде: `6 2 3 4 5`. Както се вижда, промените, направени във функцията `change_first_element`, са се отразили и извън нея. Това е основна разлика между простите типове данни и масивите - ако променяме параметри от прост тип, промените няма да се отразят извън функциите, но промените на елементи от масив се отразяват. Защо се получава така, ще разберем по-напред в курса, за сега е важно да имаме в предвид, че това се случва. Ако искаме да укажем, че функцията няма да променя елементите на масива, то преди типа на масива може да напишем ключовата дума `const`. Тогава при опит за промяна на елементите в масива ще получим компилационна грешка.

## Задача 01 - Сума

```c++
int sum(const int arr[], std::size_t size);
```

Напишете функция, която връща сумата от елементите в масив.

### Пример:

```c++
int arr[] = {16, 23, 7, 18, 39};
std::cout << sum(arr, 5); // -> 103
```

## Задача 02 - Търсене на елемент
```c++
int find(const int arr[], std::size_t size, int element);
```
Напишете функция, която по подаден масив и елемент, връща индекса на елемента в масива. Ако елементът не се среща в масива, функцията да връща -1.

### Пример:
```c++
int arr[]{8, 0, 2, 6, 9, 2, 7};
std::cout << find(arr, 7, 2); // -> 2
std::cout << find(arr, 7, 16); // -> -1
```

## Задача 03 - Множество
```c++
bool is_set(const int arr[], std::size_t size);
```
Напишете функция, която проверява дали масив е множество. Множество наричаме сортирана съвкупност от елементи, в която няма повторения.

### Пример:
```c++
int arr1[]{2, 5, 6, 11, 17};
int arr2[]{2, 5, 5, 11, 17};

std::cout<<std::boolalpha<<is_set(arr1, 5); // -> true
std::cout<<std::boolalpha<<is_set(arr2, 5); // -> false
```

## Задача 04 - Обръщане на масив
```c++
void reverse(int arr[], std::size_t size);
```
Напишете функция, която обръща реда на елементите в масив.

### Пример:
```c++
int arr[]{0, 1, 2, 3, 4};
reverse(arr, 5);
print(arr, 5); // -> 4 3 2 1 0
```

## Задача 05 - Филтриране
```c++
std::size_t filter(int destination[], const int source[], std::size_t size);
```
Напишете функция, която намира всички елементи в `source` масива, които са по-големи от 30 и се делят на 7, записва ги в масива `destination` и връща новия размер на масива `destination`.

### Пример:
```c++
int source[]{5, 14, 28, 6, 98, 24, 35, 68, 21};
int destination[255];
int size = filter(destination, source, 9);
print(destination, size); // -> 98 35
```

## Задача 06 - Най-често срещан елемент
```c++
int most_common(const int arr[], std::size_t size);
```
Напишете функция, която намира най-често срещания елемент в масив.

### Пример:
```c++
int arr[]{4, 1, 1, 4, 2, 3, 4, 4, 1, 2, 4, 9, 3};
std::cout << most_common(arr, 13); // -> 4
```

## Задача 07 - Най-дълъг подмасив
```c++
std::size_t longest_subarray_size(const int arr[], std::size_t size);
```
Напишете функция, която намира дължината на най-дългия подмасив на даден масив, който съдържа еднакви елементи.

### Пример:
```c++
int arr1[]{1, 1, 2, 3, 3, 3, 4, 2, 2, 2, 2, 1, 1};
int arr2[]{1, 1, 2, 3, 3, 3, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1};
std::cout << longest_subarray_size(arr1, 13) << '\n'; // -> 4
std::cout << longest_subarray_size(arr2, 16) << '\n'; // -> 5
```

## Задача 08 - Сортиране
```c++
void sort(int arr[], std::size_t size);
```
Напишете функция, която сортира елементите на масив по-големина в нарастващ ред. Направете 2 варианта - един чрез `bubble sort` и един чрез `selection sort`.

### Пример:
```c++
int arr[]{10, 5, 8, 3, 13, 7};
sort(arr, 6);
print(arr, 6); // -> 3 5 7 8 10 13
```