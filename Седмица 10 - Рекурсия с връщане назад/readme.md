# Седмица 10 - Рекурсия с връщане назад

## Пълно изчерпване
Пълното изчерпване (brute force) е техника за решаване на сложни задачи, при която се генерират всички възможни решения на задачата и едно по едно се проверяват дали наистина са валидни решения. Въпреки, че тази техника е ефективна, в голяма част от случаите решенията, използващи пълно изчерпване, отнемат твърде много време, което може да бъде спестено, ако чрез прости наблюдения решим да не разглеждаме част от възможните решения, понеже знаем със сигурност, че са грешни.

## Рекурсия с връщане назад
Един прост начин да намалим броя на случаите в задачите с пълно изчерпване е да използваме рекурсия с връщане назад (backtracking). Това е техника за решаване на задачи, при която рекурсивно генерираме всички възможни решения на задачата, като по този начин получаваме дървовидна структура от кандидатите за решение. След това започваме да проверяваме дали кандидатите са валидни решения като започваме един вид да "обхождаме" тази дървовидна структура. Ако сме стигнали до някой възел на тази структура и с проверка установим, че решенията, които се извеждат от този възел са невалидни, то тогава няма смисъл да ги разглеждаме. В такъв случай трябва да се "върнем" едно ниво назад и да започнем да проверяваме следващия клон на дървото.

## Схема за решаване на задачи чрез рекурсия с връщане назад
1. Започваме от някакво начално състояние;
2. Ако състоянието, в което сме в момента е валидно решение, приключваме и връщаме намереното решение;
3. Ако състоянието, в което сме в момента не е валидно решение и чрез проверка установим, че няма как да стигнем до решение, то индикираме, че няма решение, произлизащо от това състояние;
4. Ако състоянието, в което сме в момента не е валидно решение и има няколко варианта, по които да стигнем до решение, избираме един от тях и отиваме на стъпка 2. с новото състояние;
5. Ако състоянието, в което сме в момента не е валидно решение и сме изчерпили всички варианти, по които да стигнем до решение, то индикираме, че няма решение, произлизащо от това състояние;

В голяма част от задачите се налага да се пази информация през кои състояния сме минали - причината е, за да не ги повтаряме безкрайно и да зациклим. Това най-често означава, че ще ни трябва нова помощна функция, която да приема повече параметри, които ще ни трябват за тази информация. Тази помощна функция ще върши основната логика, а първоначалната функция само ще подготвя данните за втората и ще я вика, връщайки резултата, който тя дава.

## Недостатъци на рекурсията с връщане назад
Въпреки, че чрез рекурсията с връщане назад можем да намалим значително броят на проверките при търсене на решение, това не намалява асимптотичната сложност на задачата (каквото и да значи това). Има много начини да се "надгради" този алгоритъм, но в рамките на този курс ще се ограничим само до тук.

## Задача 01 - Точна сума
```c++
bool candidates_goal(unsigned candidates[], std::size_t n, unsigned target);
```
Напишете функция, която по даден масив от положителни числа, които ще наричаме кандидати, и число, което ще наричаме цел, проверява дали целта може да се получи като сума на някои от кандидатите (позволено е повторението на кандидати).

### Пример:
```c++
unsigned arr[] = {5, 3, 12};

std::cout << std::boolalpha << candidates_goal(arr, 3, 27) << '\n'; // -> true
std::cout << std::boolalpha << candidates_goal(arr, 3, 7) << '\n'; // -> false
```

## Задача 02 - Flood Fill
```c++
void flood_fill(int canvas[][255], std::size_t height, std::size_t width, int x, int y, int color);
```
Напишете функция, която приема платно (`canvas`), представено като матрица от числа, както и размерите на платното, координатите на начална точка в платното и цвят, представен като цяло число. Функцията трябва да "оцветява" всички клетки от платното, които са "свързани" с началната клетка, в подадения цвят. Да се "оцвети" клетка значи да се смени стойността в нея със стойността на новия цвят. Две клетки са "свързани", ако те са в един и същи цвят и или са съседни, или има път между тях от клетки, оцветени в същия цвят.

### Пример:
```c++
int canvas[][255]{
    {4, 2, 3, 2, 6},
    {5, 2, 2, 7, 10},
    {2, 2, 8, 2, 1},
    {9, 2, 2, 2, 3},
};

flood_fill(canvas, 4, 5, 1, 1, 20);
print_matrix(canvas, 4, 5);
/*
4   20   3    2    6
5   20   20   7    10
20  20   8    20   1
9   20   20   20   3
*/
```

## Задача 03 - Игра с числа
```c++
bool winning_sequence(int sequence[], std::size_t length);
```
Напишете функция, която приема редица от числа, и проверява дали следната игра може да завърши успешно:
- Първо се избира едно число от редицата и се премахва от нея;
- След това има 2 опции:
    - избира се друго число от редицата, което се дели на избраното, и то се премахва, като се повтаря тази стъпка с него;
    - избира се друго число от редицата, което дели избраното, и то се премахва, като се повтаря тази стъпка с него;
- Ако по този начин могат да се премахнат всички числа, играта завършва успешно.

### Бонус:
Принтирайте последователността от ходове, ако играта е успешна.

### Пример:
```c++
int sequence[]{42, 13, 17, 1, 3, 30, 10, 2, 6, 34, 2};
std::cout << std::boolalpha << winning_sequence(sequence, 11) << '\n'; // -> true
// -> 42 3 30 10 2 6 2 34 17 1 13
```

## Задача 04 - Кръстословица
```c++
unsigned find_words_in_crossword(char matrix[][255], std::size_t rows, std::size_t cols, char words[][255], std::size_t n);
```
Напишете функция, която приема кръстословица, представена като матрица от букви, както и списък от думи, и намира броя на думите от списъка, които се срещат в кръстословицата. Една дума се съдържа в кръстословицата, ако всяка буква от думата се намира в съседна клетка на предишната буква. Ако буква в дадена клетка е използвана, тя не може да се ползва втори път.

### Пример:
```c++
char matrix[][255] = {{'c', 'a', 't'},
                      {'w', 'h', 'o'},
                      {'w', 'i', 'n'}};
char words[][255] = {"cat", "hello", "what", "caca"};
std::cout << find_words_in_crossword(matrix, 3, 3, words, 4) << '\n'; // -> 2
// -> cat, what
```

## Задача 05 - Разносвач на мляко (Изпит 2021/2022)
Иванчо е започнал работа като разносвач на мляко. Той обикаля през цялото село, като през някои къщи спира, за да вземе мляко, а през някои спира, за да продава мляко. Той обаче може да носи ограничено количество мляко. Един ден, се обадила баба му, която го поканила на гости, но понеже Иванчо е на работа не е сигурен дали ще има възможност да я навести и да се върне обратно. Вашата задача е да напишете програма, която да казва на Иванчо дали ще може да мине през баба си и да се върне обратно в тях. Като вход програмата ще получава число N - размерът на селото, което ще представяме с матрица, която също се получава като вход. Всяка клетка от матрицата представлява къща от селото. Ако в клетка има положително число, то ако Иванчо мине през тази къща трябва да вземе толкова количество мляко, колкото е голямо числото. Ако има отрицателно, то той трябва да продаде толкова количество, колкото е голямо числото по модул. Освен това програмата получава като вход и координатите на къщата на Иванчо, координатите на къщата на баба му и количеството, което Иванчо може да носи. Програмата трябва да проверява дали има път от къщата на Иванчо до къщата на баба му и обратно, като Иванчо трябва да изпълнява поръчките на хората, през чиито къщи минава. Освен това Иванчо иска да е оптимален и да минава само през къщи, през които не е минавал, за да направи най-много оборот. Ако в някакъв момент Иванчо е твърде натоварен или няма достатъчно мляко да даде при посещение на някоя къща, то този път е невалиден.

### Бонус:
Ако съществува такъв път, да се изведе на екрана.

### Пример:
```
Вход:                                               Изход:
Размер: 5                                           true
Село:
1 5 6 4 -2
-4 10 4 -3 20
0 -4 2 -12 5
5 13 1 1 -7
2 7 5 0 15
Координати на къщата на Иванчо: 1 1
Координати на къщата на баба му: 4 3 
Максимално количество, което може да носи: 15


Бонус:
(1, 1) -> (2, 1) -> (2, 2) -> (3, 2) -> (4, 2) -> (4, 3) -> (3, 3) -> (2, 3) -> (1, 3) -> (1, 2) -> (1, 1)
```

## Задача 06* - Кани за вода
```c++
int water_jugs(unsigned first_max, unsigned second_max, unsigned target);
```
Напишете функция, която решава `Two Water Jugs problem`. Задачата е следната: дадени са две празни кани с капацитети (в литри) `first_max` и `second_max` като втората е с по-голям капацитет. Целта е в една от двете кани да има точно `target` литра вода, като могат да се правят следните операции:
- изпразване на една кана;
- пълнене на една кана до горе;
- преливане на вода от едната кана в другата докато първата се изпразни или втората се напълни;

### Пример:
```c++
std::cout << water_jugs(4, 3, 2) << '\n'; // -> 4
/*
fill 2 - 0, 3
move from 2 to 1 - 3, 0
fill 2 - 3, 3
move from 2 to 1 - 4, 2
*/
```