# Седмица 06 - Символни низове

## Разликата между символни низове и масив от тип `char`
На практика всеки символен низ е масив от тип `char`. Това, което го различава от обикновените масиви е, че последният му елемент задължително трябва да бъде терминиращата нула - `\0` (от там и наименованието `null-terminated string`). Да разгледаме следния пример:
```c++
char str1[5]{'a', 'b', 'c', 'd', 'e'};
char str2[6]{'a', 'b', 'c', 'd', 'e', '\0'};
char str3[6] = "abcde";
char str4[5] = "abcde";
```
Да разгледаме по отделно всеки от примерите:
- `str1` е най-обикновен масив - има 5 елемента и няма терминираща нула;
- `str2` вече е символен низ - последният елемент е терминиращата нула;
- `str3` също е символен низ - символи, оградени от двойни кавички, представляват символен низ, като автоматично на края се слага терминираща нула, въпреки, че ние не я виждаме (което е нормално, понеже `\0` е празният знак);
- `str4` дава компилационна грешка, понеже `"abcde"` е символен низ, т.е. освен 5-те знака, които виждаме има още един - терминиращата нула. Общо това са 6 знака, но капацитета на `str4` е 5.

Важното, което трябва да запомним от горния пример е следното: можем лесно да инициализираме символен низ, като използваме двойни кавички, и винаги трябва да внимаваме за размера на масива, който ще го съдържа - трябва винаги да оставим още 1 място за терминиращата нула.

## Ползата от символните низове
Ако символните низове нямаха терминираща нула, щяхме да работим с тях като с обикновени масиви. Но това щеше да е трудоемко, поради факта, че използваме символни низове на практика във всяка програма и щяхме да изразходваме твърде много усилия, за да постигнем прости резултати. Терминиращата нула променя начина, по който работим със символните низове. Основните ползи са следните:
- При подаване на символен низ на функция, не е нужно да подаваме размера - ако искаме да го обхождаме, може да го правим докато не срещнем терминираща нула;
- Извеждането на символен низ на стандартния изход е тривиално: можем директно да го изведем чрез `std::cout`. Това е така, понеже `std::cout` извежда всички елементи на низа до срещане на терминираща нула. Обърнете внимание, че ако се опитаме да изведем масив от тип `char` по този начин, може да получим невалидни данни, понеже `std::cout` няма да знае кога да спре и да започне да извежда символи, разположени след елементите на масива в паметта (което може да доведе и до Segmentation fault в някои случаи);
- Лесно може да създаваме символни низове при нужда - било то, за да изведем някакво съобщение, или за тестови цели. Просто трябва да оградим текста, който искаме да превърнем в символен низ в двойни кавички и сме готови;

## Как се въвежда символен низ от стандартния вход
За въвеждането на символен низ отново може да използваме `std::cin`, но тогава се сблъскваме с няколко проблема:
- `std::cin` чете входа до първия разделите - това включва и инервал, т.е. не можем да въведем низ, който се състои от няколко думи;
- `std::cin` не ни предпазва от въвеждане на низ с грешен размер - ако въведем низ с размер по-голям от зададения или забравим за терминиращата нула, `std::cin` ще прочете целия низ и ще се опита да го вкара в масива, при което ще получим недефинирано поведение.

Поради тези проблеми, ще предпочитаме да използваме `std::cin.getline()`. Тази функция приема два аргумента - масива, в който ще запишем низа, и размера на низа. Функцията чете до нов ред и ако се опитаме да подадем по-голям низ, то той ще бъде отрязан, така че да се събере в масива. Към размера, който подаваме влиза и терминиращата нула, понеже функцията я слага автоматично. Примерна употреба на `std::cin.getline()`:
```c++
char str[6];

std::cin.getline(str, 6);
```
В случая, въведения низ ще има максимум 5 символа и терминираща нула. Ако се опитаме да въведем `hello world`, в `str` ще се запише само `hello`.

## Библиотеката `<cstring>`
Библиотеката `<cstring>` ни предоставя функции за по-бърза работа със символни низове. Основните от тях са:
- `strcpy` - копира символен низ в нов масив, като първият аргумент е новият масив, а вторият - старият;
- `strncpy` - същото като `strcpy`, но се подава конкретния брой символи, които да се копират;
- `strcat` - конкатенира два низа в първия;
- `strncat` - същото като `strcat`, но се подава конкретния брой символи от втория низ, които да се конкатенират с първия;
- `strlen` - намира дължината на низ;
- `strcmp` - сравнява два низа лексикографски. Резултата е 0, ако съвпадат изцяло, произволно отрицателно число, ако първият е по-малък в смисъла на лексикографската наредба и произволно положително число, ако вторият е по-малък в смисъла на лексикографската наредба;
- `strncmp` - същото като `strcmp`, но се подава до колко символа да се сравняват двата низа;
- `strchr` - намира първото срещане на символ в низа;
- `strstr` - намира първото срещане на подниз в низа;

На този етап няма да използваме тази библиотека, за да можем да упражним работата със символни низове. В последствие, когато имплементираме всички функции от библиотеката сами, ще можем да я ползваме наготово. Ако ползвате `Visual Studio`, компилаторът ще ви се кара, че използвате горните версии, понеже той ги счита за "опасни". Има два начина за справеня с това - може след името на всяка функция да сложите `_s`, като това индикира, че ползвате "безопасния" вариант на функциите, но тези функции са налични само за компилатора на `Visual Studio` и не са по стандарта, съответно няма да тръгнат на други компилатори. Другата опция е да сложите следния ред най-отгоре на файла: `#pragma warning(disable: 4996)`.

## Задача 01 - Главни букви
```c++
void to_upper_case(char str[]);
```
Напишете функция, която трансформира всички букви в символен низ към главни.

### Бонус:
Напишете функция, която кодира низа спрямо ROT13 шифъра.

### Пример:
```c++
char str[] = "Hello Jimmy!";
to_upper_case(str);
std::cout << str << '\n'; // -> HELLO JIMMY!
```

## Задача 02 - От ASCII символи към числа
```c++
int atoi(const char str[]);
```
Напишете функция, която приема низ, започващ с число, и връща това число.

### Пример:
```c++
std::cout << atoi("123filler") + atoi("-81morefiller") << '\n'; // -> 42
```

## Задача 03 - Най-дълга дума
```c++
std::size_t find_longest_word(const char str[]);
```
Напишете функция, която намира индекса на първата буква от най-дългата дума в символен низ.

### Пример:
```c++
std::cout << find_longest_word("Hello, my name is Ivancho") << '\n'; // -> 18
```

## Задача 04 - Trim
```c++
void trim(char str[]);
```
Напишете функция, която премахва интервалите в началото и края на символен низ.

### Пример:
```c++
char str[] = "    Hello World     ";
trim(str);
std::cout << str << '\n'; // -> Hello World
```

## Задача 05 - Декодиране
```c++
void decode(char destination[], const char source[]);
```
Напишете функция, която "декодира" `source` низа и запазва резултата в `destination`. Под това да се "декодира" низ се има предвид всяко срещане на {<число>}{<символ>} да бъде заменено от {<символ>} <число> на брой пъти.

### Бонус:
Напишете функция, която кодира низ по горния начин.

### Пример:
```c++
char buffer[255];
decode(buffer, "a2b10c");
std::cout << buffer << '\n'; // -> abbcccccccccc
```

## Задача 06 - Търсене на дума
```c++
int find_word(const char str[], const char word[]);
```
Напишете функция, която намира индекса на първата буква на конкретна дума в даден низ. Ако тази дума не е част от низа, функцията да връща -1.

### Пример:
```c++
std::cout << find_word("I am the best programmer ever", "programmer") << '\n'; // -> 14
```

## Задача 07 - Премахване на дума
```c++
void remove_word(char str[], const char word[]);
```
Напишете функция, която премахва всички срещания на конкретна дума от низ.

### Пример:
```c++
char str[] = "I am the best programmer ever";
remove_word(str, "programmer");
std::cout << str << '\n'; // -> I am the best ever
```

## Задача 08 - Обръщане реда на думите
```c++
void reverse_sentence(char destination[], const char source[]);
```
Напишете функция, която обръща реда на думите в низ, и записва резултата в `destination` масив.

### Пример:
```c++
char buffer[255];
reverse_sentence(buffer, "May the force be with you");
std::cout << buffer << '\n'; // -> you with be force the May
```

## Задача 09 - Замяна на дума
```c++
void replace_word(char str[], const char word1[], const char word2[]);
```
Напишете функция, която заменя всяко срещане на думата `word1` в низ с думата `word2`.

### Пример:
```c++
char str[] = "I am the best programmer ever";
replace_word(str, "programmer", "boxer");
std::cout << str << '\n'; // -> I am the best boxer ever
```